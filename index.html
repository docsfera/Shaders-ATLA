<!DOCTYPE html>
<html lang="en">
  <head>
    <title>Blender-to-Three.js App Template</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <style>
      body {
        margin: 0px;
      }
    </style>
  </head>

  <body>
    <script type="module">


      import * as THREE from './three.module.js';

      import { OrbitControls } from './OrbitControls.js';
      import { GLTFLoader } from './GLTFLoader.js';
      import {TextureLoader} from "./three/src/loaders/TextureLoader.js"
      import {AnimationMixer} from "./three/src/animation/AnimationMixer.js"
      //import { GLTFExporter } from './three/addons/exporters/GLTFExporter.js';
      //import { RGBELoader } from './RGBELoader.js';

      let camera, scene, renderer;
      let TIME = 0

      let isStartAnimation = false
      let spendedTimeBeforeGoStart = 0

      document.addEventListener("mousedown", () => isStartAnimation = true)

      init();
      //render();



      function init() {

        const container = document.createElement( 'div' );
        document.body.appendChild( container );

        camera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 0.25, 20 );
        camera.position.set( - 1.8, 0.6, 2.7 );

        scene = new THREE.Scene();



//         const light = new THREE.PointLight( 0xff0000, 1, 100 );
// light.position.set( 50, 50, 50 );
// scene.add( light );

//         const color = 0xFFFFFF;
// const intensity = 1;
// const light = new THREE.AmbientLight(color, intensity);
// scene.add(light);

        let animationAction, mixer;

        const cube = new THREE.BoxGeometry(0.5,0.5,0.5)
        const material = new THREE.ShaderMaterial({
          side:THREE.DoubleSide,

            uniforms: {
                diffuse: { value: new THREE.Color(0xffffff) },
                uTime: { type: "f", value: 0 },
                iResolution:  { value: new THREE.Vector3() },
                uFrequency:  { type: "f", value: 0 },
                uScaleY: { type: "f", value: 0.1 },
            },
            vertexShader: `
                uniform float uTime; 
                uniform float uFrequency;
                uniform float uScaleY;
                varying vec2 vUv;
                varying vec3 vPosition;
                varying float vNoise;



                float pseudoRandom(float seed) {
                    return fract(sin(seed) * 43758.5453);
                }

                float noise(vec3 point) {
                    float dt = dot(point, vec3(12.9898, 78.233, 123.45));
                    float sn = (sin(dt) * 43758.5453123);
                    return fract(sn);
                }
                




                void main() {
                    vUv = uv;
                    

                    // Пламенная анимация
                    float noiseFactor = noise(position + uTime);
                    vec3 pos = position * 0.3;
                    pos.x = pos.x * 0.5;
                    pos.y = pos.y * uScaleY;
                    
                    // Манипулирование вершинами на конце (вдоль положительного Y)
                    if (pos.y > uFrequency) {
                        pos.x += sin(uTime + pos.y) * (noiseFactor - 0.5) * 5.0;
                        pos.y += noiseFactor * 5.0;
                        pos.z += cos(uTime + pos.y) * (noiseFactor - 0.5) * 5.0;
                    }

                    pos.x +=sin(.3 * pos.y + uTime*20.0) * 0.05;

                    vNoise = noiseFactor * 1.5;

                    vPosition = position;

                    //gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);

                    // vec3 newPosition = position;
                     vec3 displacedPosition = pos * vec3(1.5, 8.0, 1.5);
                    
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(displacedPosition, 1.0);
                }
                `,
            fragmentShader: `
                uniform float uTime; 
                varying vec2 vUv;
                varying float vNoise;
                varying vec3 vPosition;

                float random (vec2 st) {
                    return fract(sin(dot(st.xy,
                                         vec2(12.9898,78.233)))*
                        43758.5453123 * abs(sin(uTime)));
                }
                void main() {

                    float rnd = random( vUv );

                      // Высота относительно центра огня
                    float heightFactor = smoothstep(0.0, 30.0, vPosition.y);

                    // Определяем цвета для эффекта пламени
                    vec3 colorBottom = vec3(1.0, 1.0, 0.0); // Желтый
                    vec3 colorMiddle = vec3(1.0, 0.5, 0.0); // Оранжевый
                    vec3 colorTop = vec3(1.0, 0.0, 0.0); // Красный

                    // Смешиваем цвета, используя шум и высоту для создания эффекта пламени
                    vec3 color = mix(colorBottom, colorMiddle, clamp(vNoise + 0.2, 0.0, 1.0));
                    color = mix(color, colorTop, heightFactor);

                    // Плавные переходы между цветами с точечным эффектом
                    color *= (1.0 - heightFactor) + vNoise * heightFactor;

                    gl_FragColor = vec4(color, 1.0);

                }
                `
        });
        material.uniforms.diffuse.value = new THREE.Color(0,1,1);
        material.uniforms.uTime.value = TIME
        material.uniforms.uFrequency.value = 2.0

        material.transparent = true;
        
        const mesh = new THREE.Mesh(cube, material)
        mesh.position.x = -2
        //scene.add(mesh)


        const planeGeometry = new THREE.PlaneGeometry(3,3,3)
        const geometry = new THREE.SphereGeometry( 0.4, 32, 32 ); 


        const plane = new THREE.Mesh(planeGeometry, material)
        plane.name = "plane"
        plane.position.x = 2


        const sphere = new THREE.Mesh(geometry, material)
        //sphere.rotation.y = Math.PI / 2
        sphere.rotation.z = Math.PI / 2
        sphere.position.x = -0.4
        sphere.position.y = 0.1
        scene.add(sphere)

        console.log(camera.position)
        camera.position.set(0,0,5)

        const backgrondPlaneGeometry = new THREE.PlaneGeometry(12,4.2)
        //const backgrondPlaneMaterial = new THREE.StandardMaterial({color: "#ffffff"}) 
        

        const loader = new THREE.TextureLoader();
        const texture = loader.load( './background.jpg' );
        //texture.colorSpace = THREE.SRGBColorSpace;
         
        const backgrondPlaneMaterial = new THREE.MeshPhongMaterial({
          color: 0xFF8844,
          map: texture,
        });

        const backgrondPlane = new THREE.Mesh(backgrondPlaneGeometry, backgrondPlaneMaterial)
        backgrondPlane.position.x = 0
        backgrondPlane.position.y = 0
        backgrondPlane.position.z = -1

        backgrondPlane.receiveShadow = true;


        scene.add(backgrondPlane)



         const loader2 = new GLTFLoader();
            loader2.load( 'zuko2.gltf', function ( gltf ) {
              const g = gltf.scene
              g.castShadow = true;
              g.receiveShadow = true;


              g.traverse(node => {
                if(node.isMesh) node.castShadow = true
              })

              g.rotation.y = Math.PI / 4
              g.position.x = -2

              scene.add( g );

              console.log({gltf})

              console.log(scene)
              scene.children[2].position.z = 0.5
              scene.children[2].position.y = -1

              const light =  new THREE.DirectionalLight("#ffffff", 0.2);
              var cameraNear = 1, cameraFar = 5000;
              light.castShadow = true;
              light.shadow.mapSize.width = 4024;
              light.shadow.mapSize.height = 4024;
              light.shadow.camera.near = cameraNear;
              light.shadow.camera.far = cameraFar;


             light.position.z = 400
             light.position.x = 200
             light.position.y = 100

              //light.intensity = 2
              scene.add( light );


              const light2 = new THREE.AmbientLight( 0xffffff );
              light2.intensity = 0.8
              scene.add( light2 );

              

              mixer = new AnimationMixer(gltf.scene)

              console.log({mixer})

              animationAction = mixer.clipAction(gltf.animations[0])
              animationAction.setLoop(THREE.LoopOnce);
              animationAction.clampWhenFinished = true;
              animationAction.enable = true;

              console.log(animationAction)


              

              


              render();

            } );

        //scene.add(plane)

        // new RGBELoader()
        //   .load( 'environment.hdr', function ( texture ) {

        //     texture.mapping = THREE.EquirectangularReflectionMapping;

        //     scene.background = texture;
        //     scene.environment = texture;

        //     render();

        //     // model

        //     // const loader = new GLTFLoader();
        //     // loader.load( 'suzanne.gltf', function ( gltf ) {

        //     //   scene.add( gltf.scene );

        //     //   render();

        //     // } );

        //   } );


        

        renderer = new THREE.WebGLRenderer();
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.BasicShadowMap;
        renderer.setPixelRatio( window.devicePixelRatio );
        renderer.setSize( window.innerWidth, window.innerHeight );
        // renderer.toneMapping = THREE.ACESFilmicToneMapping;
        // renderer.toneMappingExposure = 1;
        // renderer.outputEncoding = THREE.sRGBEncoding;
        container.appendChild( renderer.domElement );

        const controls = new OrbitControls( camera, renderer.domElement );
        //controls.addEventListener( 'change', render ); // use if there is no animation loop
        controls.minDistance = 2;
        controls.maxDistance = 40;
        controls.target.set( 0, 0, - 0.2 );
        controls.update();

        window.addEventListener( 'resize', onWindowResize );

              function resizeRendererToDisplaySize(renderer) {
        const canvas = renderer.domElement;
        const width = canvas.clientWidth;
        const height = canvas.clientHeight;
        const needResize = canvas.width !== width || canvas.height !== height;
        if (needResize) {
          renderer.setSize(width, height, false);
        }
        return needResize;
      }

      function updateUniforms() {
          scene.traverse((child) => {
              if (child instanceof THREE.Mesh
                  && child.material.type === 'ShaderMaterial') {
                  //console.log({TIME, time: child.material.uniforms})
                  child.material.uniforms.uTime.value = TIME;
                  resizeRendererToDisplaySize(renderer);
 
                  const canvas = renderer.domElement;
                  const plane = scene.children.find(child => child.name == "plane")
                  //child.material.uniforms.iResolution.value.set(1000, 1000, 1);
                  child.material.needsUpdate = true;
              }
          });
          
        }

      function onWindowResize() {

        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();

        renderer.setSize( window.innerWidth, window.innerHeight );

        render();

      }

      //

      const clock = new THREE.Clock()
      //sphere.visible = true
      //sphere.layers.set(2)
      //sphere.position.y = -10000
      //sphere.rotation.y = -Math.PI / 4
      sphere.frustumCulled = false;

      let once = false

      function render() {


        TIME += 0.005;

        // if(TIME > 1.2){
        //   isStartAnimation = true
        // }

        if(animationAction && isStartAnimation){
          mixer.update(clock.getDelta()) // THIS IS ANIMATION
         // console.log("play")
          animationAction.play()
        }

        if(!isStartAnimation){
          spendedTimeBeforeGoStart = TIME
        }

        requestAnimationFrame(render)

        
        
        
        updateUniforms();

        const timeForStartFirstFire = 0.2


         if(TIME > timeForStartFirstFire + spendedTimeBeforeGoStart){
          sphere.position.x += 0.4

          //material.uniforms.uScaleY.value = 1.4
          if(material.uniforms.uScaleY.value < 1.4){
            material.uniforms.uScaleY.value = material.uniforms.uScaleY.value + 0.4
          }
          

          //material.uniforms.uScaleY.value = material.uniforms.uScaleY.value + 0.1
          
        }else{
          
        }

        if(TIME > 0.01 && TIME < timeForStartFirstFire){
          //sphere.visible = false
          sphere.scale.set(0,0,0)
        }

        // scaling sphere
        //console.log({TIME, spendedTimeBeforeGoStart, timeForStartFirstFire})
        if(TIME > spendedTimeBeforeGoStart + timeForStartFirstFire  && isStartAnimation){
          const h = 0.3 + (TIME - timeForStartFirstFire) *6
          //sphere.scale.set(h,h,h)
          sphere.scale.set(1,1,1)
        }

        console.log("render")
        renderer.render( scene, camera );
        

      }

      render()

      }



    </script>

  </body>
</html>
