<!DOCTYPE html>
<html lang="en">
  <head>
    <title>Blender-to-Three.js App Template</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <style>
      body {
        margin: 0px;
      }
    </style>
  </head>

  <body>
    <script type="module">


      import * as THREE from './three.module.js';

      import {firstFireVertexShader, firstFireFragmentShader} from './shaders/firstFireMaterial.js'

      import { OrbitControls } from './OrbitControls.js';
      import { GLTFLoader } from './GLTFLoader.js';
      import {TextureLoader} from "./three/src/loaders/TextureLoader.js"
      import {AnimationMixer} from "./three/src/animation/AnimationMixer.js"
      import { GUI } from './three/examples/jsm/libs/lil-gui.module.min.js'
      //import { GLTFExporter } from './three/addons/exporters/GLTFExporter.js';
      //import { RGBELoader } from './RGBELoader.js';

      let camera, scene, renderer;
      let TIME = 0

      let isStartAnimation = false
      let isAnimationEnd = false
      let spendedTimeBeforeGoStart = 0

      let torus

      const timeForStartFirstFire = 0.08
      const timeForStartTorusFire = 0.23
      const timeForStartThirdFire = 0.45
      const timeForStartFourFire = 0.52
      const timeForStartFiveFire = 0.62


      let acseleration = 0

      document.addEventListener("keydown", () => isStartAnimation = true)

      let posXClicked = undefined
      let prevRotation = undefined

      document.addEventListener("mousedown", e => {
        posXClicked = e.clientX
        const pivot = scene.children.find(child => child.name == "pivot")
        if(pivot){
          prevRotation = pivot.rotation.y
        }
        // console.log(scene)
        // console.log(e.target.clientWidth)
      })
      document.addEventListener("mouseup", e => {
        posXClicked = undefined
        prevRotation = undefined
      })

      document.addEventListener("mousemove", e => {
        if(posXClicked && scene && isAnimationEnd){
          //scene.children.find(child => child.name == "Scene").rotation.y = (e.clientX - posXClicked) / e.target.clientWidth * Math.PI
          scene.children.find(child => child.name == "pivot").rotation.y = prevRotation + 
          (e.clientX - posXClicked) / e.target.clientWidth * 2 * Math.PI
        }
      })

      init();



      function init() {

        const container = document.createElement( 'div' );
        document.body.appendChild( container );

        camera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 0.25, 20 );
        camera.position.set( - 1.8, 0.6, 2.7 );

        scene = new THREE.Scene();



//         const light = new THREE.PointLight( 0xff0000, 1, 100 );
// light.position.set( 50, 50, 50 );
// scene.add( light );

//         const color = 0xFFFFFF;
// const intensity = 1;
// const light = new THREE.AmbientLight(color, intensity);
// scene.add(light);

        let animationAction, mixer;

        const material = new THREE.ShaderMaterial({
          side:THREE.DoubleSide,
            uniforms: {
                diffuse: { value: new THREE.Color(0xffffff) },
                uTime: { type: "f", value: 0 },
                iResolution:  { value: new THREE.Vector3() },
                uFrequency:  { type: "f", value: 0 },
                uScaleY: { type: "f", value: 0.1 },
            },
            vertexShader: firstFireVertexShader,
            fragmentShader: firstFireFragmentShader
        })
        material.uniforms.diffuse.value = new THREE.Color(0,1,1);
        material.uniforms.uTime.value = TIME
        material.uniforms.uFrequency.value = 2.0

        material.transparent = true

        const planeGeometry = new THREE.PlaneGeometry(3,3,3)
        const geometry = new THREE.SphereGeometry( 0.4, 32, 32 ); 


        const plane = new THREE.Mesh(planeGeometry, material)
        plane.name = "plane"
        plane.position.x = 2


        const sphere = new THREE.Mesh(geometry, material)
        sphere.rotation.z = Math.PI / 2
        sphere.position.x = -0.4
        sphere.position.y = 0.1
        scene.add(sphere)

        camera.position.set(0,0,5)

        const backgrondPlaneGeometry = new THREE.PlaneGeometry(14,4.6)
        

        const loader = new THREE.TextureLoader();
        const texture = loader.load( './background.jpg' );
        //texture.colorSpace = THREE.SRGBColorSpace;
         
        const backgrondPlaneMaterial = new THREE.MeshPhongMaterial({
          color: 0xFF8844,
          map: texture,
        });

        const backgrondPlane = new THREE.Mesh(backgrondPlaneGeometry, backgrondPlaneMaterial)
        backgrondPlane.position.x = 0
        backgrondPlane.position.y = 1
        //backgrondPlane.position.z = -0.1

        backgrondPlane.receiveShadow = true;


        scene.add(backgrondPlane)


        // floor

        const floor = new THREE.Mesh(new THREE.BoxGeometry(10,1,10), new THREE.MeshPhongMaterial({color: 0x000000}))
        floor.position.y = -1.50
        scene.add(floor)




        const thirdFire = new THREE.Mesh(geometry, material.clone())
        const fourFire = new THREE.Mesh(geometry, material.clone())
        const fiveFire = new THREE.Mesh(geometry, material.clone())
        const sixFire = new THREE.Mesh(geometry, material.clone())
        const sevenFire = new THREE.Mesh(geometry, material.clone())

        const pointLight = new THREE.PointLight("#FFAB0F", 10)
        pointLight.distance = 1
        scene.add(pointLight)

        

         const loader2 = new GLTFLoader();
            loader2.load( 'zuko5.gltf', function ( gltf ) { // zuko3.gltf
              const g = gltf.scene
              g.castShadow = true;
              g.receiveShadow = true;


              g.traverse(node => {
                if(node.isMesh) node.castShadow = true
              })

              //g.rotation.y = Math.PI / 4
              //g.position.x = -2
              //g.position.z = -5

              scene.add( g )
              // scene.children[2].position.z = 0.5
              // scene.children[2].position.y = -1

              var pivot = new THREE.Group();
              scene.add( pivot );
              pivot.name = "pivot"

              pivot.add( g );
              pivot.position.x = -1.85
              pivot.position.z = 0.5
              //pivot.position.z = -0.1

              //g.position.set( 4, - 3, - 5 )
              g.position.set( -1.0, -1, -0.05)

              const cube = new THREE.Mesh(new THREE.BoxGeometry(0.05, 0.05, 0.05), new THREE.MeshBasicMaterial({color: 0xFF0000}))
              scene.add(cube)
              cube.position.copy(g.position)

              const cube1 = new THREE.Mesh(new THREE.BoxGeometry(0.01, 5, 0.01), new THREE.MeshBasicMaterial({color: 0x00ff00}))
              scene.add(cube1)
              cube1.position.copy(pivot.position)

              const light =  new THREE.DirectionalLight("#ffffff", 0.2);
              var cameraNear = 0.01, cameraFar = 5000;
              light.castShadow = true;
              light.shadow.mapSize.width = 4024;
              light.shadow.mapSize.height = 4024;
              light.shadow.camera.near = cameraNear;
              light.shadow.camera.far = cameraFar;


              light.position.z = 400
              light.position.x = 200
              light.position.y = 100

              //light.intensity = 2
              scene.add( light )


              const light2 = new THREE.AmbientLight( 0xffffff );
              light2.intensity = 0.4
              scene.add( light2 );

              

            
              mixer = new AnimationMixer(gltf.scene)

              animationAction = mixer.clipAction(gltf.animations[0])
              animationAction.setLoop(THREE.LoopOnce);
              animationAction.clampWhenFinished = true;
              animationAction.enable = true;

              ///  WTF

              const geometry2 = new THREE.TorusGeometry(0.3, 0.1, 8, 16, Math.PI)
              //const material2 = new THREE.MeshBasicMaterial({color: 0xffff00 })

              const material2 = new THREE.ShaderMaterial({
                side:THREE.DoubleSide,
                  uniforms: {
                      uTime: { type: "f", value: 0 },
                      uTimeForStartTorusFire: { type: "f", value: timeForStartTorusFire },
                      uSpendedTimeBeforeGoStart: { type: "f", value: spendedTimeBeforeGoStart },
                      
                  },
                  transparent: true,
                  vertexShader: `
                  uniform float uTime;
                  varying vec2 vUv;
                  varying vec3 vPosition;
                  varying float vNoise;

                  float pseudoRandom(float seed) {
                    return fract(sin(seed) * 43758.5453);
                  }

                  float noise(vec3 point) {
                    float dt = dot(point, vec3(12.9898, 78.233, 123.45));
                    float sn = (sin(dt) * 43758.5453123);
                    return fract(sn);
                  }

                  void main() {
                    vUv = uv;
                    vPosition = position;

                    float noiseFactor = noise(position + uTime);
                    vNoise = noiseFactor * 1.5;

                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                  }

                  `,
                  fragmentShader: `
                  uniform float uTime; 
                  uniform float uTimeForStartTorusFire;
                  uniform float uSpendedTimeBeforeGoStart;
                  varying vec2 vUv;
                  varying vec3 vPosition;
                  varying float vNoise;

                  float random (vec2 st) {
                    return fract(sin(dot(st.xy,vec2(12.9898,78.233)))*43758.5453123 * abs(sin(uTime)));
                  }

                  void main() {

                    float rnd = random( vUv );

                    // Высота относительно центра огня
                    float heightFactor = smoothstep(0.0, 30.0, vPosition.y);

                    // Определяем цвета для эффекта пламени
                    vec3 colorBottom = vec3(1.0, 1.0, 0.0); // Желтый
                    vec3 colorMiddle = vec3(1.0, 0.5, 0.0); // Оранжевый
                    vec3 colorTop = vec3(1.0, 0.0, 0.0); // Красный

                    // Смешиваем цвета, используя шум и высоту для создания эффекта пламени
                    vec3 color = mix(colorBottom, colorMiddle, clamp(vNoise + 0.2, 0.0, 1.0));
                    color = mix(color, colorTop, heightFactor);

                    // Плавные переходы между цветами с точечным эффектом
                    color *= (1.0 - heightFactor) + vNoise * heightFactor;

                    float alpha = 0.0;
                    if(vUv.x < (uTime - uSpendedTimeBeforeGoStart - uTimeForStartTorusFire) * 10.0){
                      alpha = 1.0;
                    }

                    gl_FragColor = vec4(color, alpha);
                    
                  }`
              })



              torus = new THREE.Mesh(geometry2, material2)

              scene.add(torus)



              torus.rotation.z = -Math.PI / 2
              torus.rotation.x = Math.PI + Math.PI / 2 + Math.PI  / 6
              torus.rotation.y = -Math.PI / 8

              torus.position.x = -0.5


              /// THIRD
              thirdFire.rotation.z = -Math.PI / 4
              thirdFire.position.x = 1.4
              thirdFire.position.y = 0.9
              scene.add(thirdFire)

              //FOUR

              fourFire.position.x = 1.7
              fourFire.position.y = 0.35
              fourFire.rotation.z = -Math.PI / 2
              scene.add(fourFire)

              // FIVE

              fiveFire.position.x = 1.7
              fiveFire.position.y = 0.2
              fiveFire.rotation.z = -Math.PI / 2
              scene.add(fiveFire)

              // SIX

              sixFire.position.x = -1.7
              sixFire.position.y = 0.2
              sixFire.rotation.z = -Math.PI / 2
              scene.add(sixFire)

              // SEVEN

              sevenFire.position.x = -2.2
              sevenFire.position.y = 0.8
              sevenFire.rotation.z = Math.PI / 4
              scene.add(sevenFire)


              

              render()
          })





        renderer = new THREE.WebGLRenderer()
        renderer.shadowMap.enabled = true
        renderer.shadowMap.type = THREE.BasicShadowMap
        renderer.setPixelRatio( window.devicePixelRatio )
        renderer.setSize( window.innerWidth, window.innerHeight )
        // renderer.toneMapping = THREE.ACESFilmicToneMapping;
        // renderer.toneMappingExposure = 1;
        // renderer.outputEncoding = THREE.sRGBEncoding;
        container.appendChild( renderer.domElement );


        const gui = new GUI()

        const gg = {"controls": false, "visible": true}

        const controls = new OrbitControls( camera, renderer.domElement );
        controls.minDistance = 2;
        controls.maxDistance = 40;
        controls.target.set( 0, 0, - 0.2 );
        controls.enableRotate = false;
        controls.update();

        gui.add(gg, "controls").onChange(e => {
          if(e){
            controls.enableRotate = true;
          }else{
            // to disable rotation
            controls.enableRotate = false;
          }
        })

        gui.add(gg, "visible").onChange(bool => {
          scene.children.find(child => child.name == "pivot").traverse(_ => _.visible = bool)
        })

        gui.add(pointLight, "distance").min(0).max(10)
        gui.add(pointLight, "intensity").min(0).max(10)

        window.addEventListener( 'resize', onWindowResize )

      function resizeRendererToDisplaySize(renderer) {
        const canvas = renderer.domElement
        const width = canvas.clientWidth
        const height = canvas.clientHeight
        const needResize = canvas.width !== width || canvas.height !== height
        if (needResize) {
          renderer.setSize(width, height, false)
        }
        return needResize
      }

      function updateUniforms() {
        scene.traverse((child) => {
          if (child instanceof THREE.Mesh && child.material.type === 'ShaderMaterial' && child.material.uniforms.uTime) {
            child.material.uniforms.uTime.value = TIME
            resizeRendererToDisplaySize(renderer)
 
            const canvas = renderer.domElement
            const plane = scene.children.find(child => child.name == "plane")
            child.material.needsUpdate = true;
          }
        })       
      }

      function onWindowResize() {

        camera.aspect = window.innerWidth / window.innerHeight
        camera.updateProjectionMatrix()

        renderer.setSize( window.innerWidth, window.innerHeight )

        render()

      }

      const clock = new THREE.Clock()
      sphere.frustumCulled = false;

      let once = false

      function render() {
        //camera.lookAt(0, -0.2, 0)

        TIME += 0.005;

        // if(TIME > 1.2){
        //   isStartAnimation = true
        // }

        //console.log(clock)
        if(animationAction && isStartAnimation){
          mixer.update(clock.getDelta()) // THIS IS ANIMATION

          animationAction.play()
        }

        //console.log(mixer.time)

        if(!isStartAnimation){
          spendedTimeBeforeGoStart = TIME
          torus.material.uniforms.uSpendedTimeBeforeGoStart.value = TIME
        }

        requestAnimationFrame(render)
        updateUniforms()

        if(mixer.time > 0.4){
          sphere.position.x += 0.4
          pointLight.distance = 6
          pointLight.position.y = 2
          pointLight.position.x = sphere.position.x
          //pointLight.position.copy(sphere.position)
          if(material.uniforms.uScaleY.value < 1.4){
            material.uniforms.uScaleY.value = material.uniforms.uScaleY.value + 0.4
          }
        }

        if(mixer.time > 0.6){
          acseleration += 0.002

          torus.position.x += 0.07 + acseleration
          torus.position.y += 0.035 + acseleration

          pointLight.position.copy(torus.position)
          // pointLight.position.y = 2
          // pointLight.position.x = sphere.position.x

          if(torus.scale.x < 5){
            torus.scale.x += 0.125
            torus.scale.y += 0.125
            torus.scale.z += 0.05
          }
        }

        if(mixer.time > 1.7){ //TIME > timeForStartThirdFire + spendedTimeBeforeGoStart
          thirdFire.scale.set(1,1,1)
          thirdFire.position.x += 0.4
          thirdFire.position.y += 0.4
          pointLight.position.copy(thirdFire.position)
          if(thirdFire.material.uniforms.uScaleY.value < 1.4){
            thirdFire.material.uniforms.uScaleY.value = thirdFire.material.uniforms.uScaleY.value + 0.4
          }
        }

        if(mixer.time > 2){ //TIME > timeForStartFourFire + spendedTimeBeforeGoStart
          fourFire.scale.set(1,1,1)
          fourFire.position.x += 0.4
          pointLight.position.copy(fourFire.position)
          if(fourFire.material.uniforms.uScaleY.value < 1.4){
            fourFire.material.uniforms.uScaleY.value = fourFire.material.uniforms.uScaleY.value + 0.4
          }
        }

        if(mixer.time > 2.4){ // TIME > timeForStartFiveFire + spendedTimeBeforeGoStart
          fiveFire.scale.set(1,1,1)
          fiveFire.position.x += 0.4
          pointLight.position.copy(fiveFire.position)
          if(fiveFire.material.uniforms.uScaleY.value < 1.4){
            fiveFire.material.uniforms.uScaleY.value = fiveFire.material.uniforms.uScaleY.value + 0.4
          }
        }
        if(mixer.time > 3.2){ // TIME > timeForStartFiveFire + spendedTimeBeforeGoStart
          sixFire.scale.set(1,1,1)
          sixFire.position.x -= 0.4
          pointLight.position.copy(sixFire.position)
          if(sixFire.material.uniforms.uScaleY.value < 1.4){
            sixFire.material.uniforms.uScaleY.value = sixFire.material.uniforms.uScaleY.value + 0.4
          }
        }
        if(mixer.time > 4){
          sevenFire.scale.set(1,1,1)
          pointLight.position.copy(sevenFire.position)
          sevenFire.position.x -= 0.4
          sevenFire.position.y += 0.4
          if(sevenFire.material.uniforms.uScaleY.value < 1.4){
            sevenFire.material.uniforms.uScaleY.value = sevenFire.material.uniforms.uScaleY.value + 0.4
          }
        }

        if(mixer.time > 5){
          isAnimationEnd = true
        }

        if(TIME > 0.01 && TIME < timeForStartFirstFire){
          //sphere.visible = false
          sphere.scale.set(0,0,0)
          torus.scale.set(0,0,0)
          thirdFire.scale.set(0,0,0)
          fourFire.scale.set(0,0,0)
          fiveFire.scale.set(0,0,0)
          sixFire.scale.set(0,0,0)
          sevenFire.scale.set(0,0,0)
        }

        // scaling sphere
        if(TIME > spendedTimeBeforeGoStart + timeForStartFirstFire  && isStartAnimation){
          const h = 0.3 + (TIME - timeForStartFirstFire) *6
          //sphere.scale.set(h,h,h)
          sphere.scale.set(1,1,1)
        }


        


        renderer.render( scene, camera )
      }

      render()

      }

      



    </script>

  </body>
</html>