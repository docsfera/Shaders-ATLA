<!DOCTYPE html>
<html lang="en">
  <head>
    <title>Blender-to-Three.js App Template</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <style>
      body {
        margin: 0px;
      }
    </style>
  </head>

  <body>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tween.js/20.0.0/tween.umd.js"></script>
    <script type="module">


      import * as THREE from './three.module.js';

      import {firstFireVertexShader, firstFireFragmentShader} from './shaders/firstFireMaterial.js'

      import { OrbitControls } from './OrbitControls.js';
      import { GLTFLoader } from './GLTFLoader.js';
      import {TextureLoader} from "./three/src/loaders/TextureLoader.js"
      import {AnimationMixer} from "./three/src/animation/AnimationMixer.js"
      import { GUI } from './three/examples/jsm/libs/lil-gui.module.min.js'
      //import { GLTFExporter } from './three/addons/exporters/GLTFExporter.js';
      //import { RGBELoader } from './RGBELoader.js';

      let camera, scene, renderer;
      let TIME = 0

      let isStartAnimation = false
      let isAnimationEnd = false
      let spendedTimeBeforeGoStart = 0

      let torus

      const timeForStartFirstFire = 0.08
      const timeForStartTorusFire = 0.23
      const timeForStartThirdFire = 0.45
      const timeForStartFourFire = 0.52
      const timeForStartFiveFire = 0.62

      let isPlayIn = false


      let acseleration = 0
      let realFire

      document.addEventListener("keydown", () => isStartAnimation = true)

      let posXClicked = undefined
      let prevRotation = undefined

      document.addEventListener("mousedown", e => {
        posXClicked = e.clientX
        const pivot = scene.children.find(child => child.name == "pivot")
        if(pivot){
          prevRotation = pivot.rotation.y
        }
        console.log(scene)
        // console.log(e.target.clientWidth)
      })
      document.addEventListener("mouseup", e => {
        posXClicked = undefined
        prevRotation = undefined
      })

      document.addEventListener("mousemove", e => {
        if(posXClicked && scene && isAnimationEnd){
          //scene.children.find(child => child.name == "Scene").rotation.y = (e.clientX - posXClicked) / e.target.clientWidth * Math.
          const pivot = scene.children.find(child => child.name == "pivot")

          pivot.rotation.y = prevRotation + 
          (e.clientX - posXClicked) / e.target.clientWidth * 2 * Math.PI

          realFire.lookAt(camera.position)

        }
      })

      init();



      function init() {

        const container = document.createElement( 'div' );
        document.body.appendChild( container );

        camera = new THREE.PerspectiveCamera( 20, window.innerWidth / window.innerHeight, 0.25, 20 );
        scene = new THREE.Scene();



//         const light = new THREE.PointLight( 0xff0000, 1, 100 );
// light.position.set( 50, 50, 50 );
// scene.add( light );

//         const color = 0xFFFFFF;
// const intensity = 1;
// const light = new THREE.AmbientLight(color, intensity);
// scene.add(light);

        let animationAction, mixer;

        const material = new THREE.ShaderMaterial({
          side:THREE.DoubleSide,
            uniforms: {
                diffuse: { value: new THREE.Color(0xffffff) },
                uTime: { type: "f", value: 0 },
                iResolution:  { value: new THREE.Vector3() },
                uFrequency:  { type: "f", value: 0 },
                uScaleY: { type: "f", value: 0.1 },
            },
            vertexShader: firstFireVertexShader,
            fragmentShader: firstFireFragmentShader
        })
        material.uniforms.diffuse.value = new THREE.Color(0,1,1);
        material.uniforms.uTime.value = TIME
        material.uniforms.uFrequency.value = 2.0

        material.transparent = true

        const planeGeometry = new THREE.PlaneGeometry(3,3,3)
        const geometry = new THREE.SphereGeometry( 0.4, 32, 32 ); 


        const plane = new THREE.Mesh(planeGeometry, material)
        plane.name = "plane"
        plane.position.x = 2


        const sphere = new THREE.Mesh(geometry, material)
        sphere.rotation.z = Math.PI / 2
        sphere.position.x = -0.4
        sphere.position.y = 0.1
        scene.add(sphere)

        //camera.position.set(0,0,5)
        camera.position.set(-0.8, 0, 10)
        camera.lookAt(new THREE.Vector3(10, 0, 0))

        const backgrondPlaneGeometry = new THREE.PlaneGeometry(14,4.6)
        

        const loader = new THREE.TextureLoader();
        const texture = loader.load( './background.jpg' );
        //texture.colorSpace = THREE.SRGBColorSpace;
         
        const backgrondPlaneMaterial = new THREE.MeshPhongMaterial({
          color: 0xFF8844,
          map: texture,
        });

        const backgrondPlane = new THREE.Mesh(backgrondPlaneGeometry, backgrondPlaneMaterial)
        backgrondPlane.position.x = 0
        backgrondPlane.position.y = 1

        const realFireShader = new THREE.ShaderMaterial({
          uniforms: {iTime: { type: "f", value: 1.0 }},
          vertexShader: `
        uniform float iTime;
        varying vec2 vUv;
        void main() {
            vec3 pos = position;
            vUv = uv;
            //pos.y += sin(pos.y + time * 2.0) * 0.2;
            gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);
        }
        `,
          fragmentShader: `
        uniform float iTime;

        varying vec2 vUv;


        vec2 hash( vec2 p )
        {
            p = vec2( dot(p,vec2(127.1,311.7)),
                     dot(p,vec2(269.5,183.3)) );
            return -1.0 + 2.0*fract(sin(p)*43758.5453123);
        }

        float noise( in vec2 p )
        {
            const float K1 = 0.366025404; // (sqrt(3)-1)/2;
            const float K2 = 0.211324865; // (3-sqrt(3))/6;
            
            vec2 i = floor( p + (p.x+p.y)*K1 );
            
            vec2 a = p - i + (i.x+i.y)*K2;
            vec2 o = (a.x>a.y) ? vec2(1.0,0.0) : vec2(0.0,1.0);
            vec2 b = a - o + K2;
            vec2 c = a - 1.0 + 2.0*K2;
            
            vec3 h = max( 0.5-vec3(dot(a,a), dot(b,b), dot(c,c) ), 0.0 );
            
            vec3 n = h*h*h*h*vec3( dot(a,hash(i+0.0)), dot(b,hash(i+o)), dot(c,hash(i+1.0)));
            
            return dot( n, vec3(70.0) );
        }
        float fbm(vec2 uv)
        {
            float f;
            mat2 m = mat2( 1.6,  1.2, -1.2,  1.6 );
            f  = 0.5000*noise( uv ); uv = m*uv;
            f += 0.2500*noise( uv ); uv = m*uv;
            f += 0.1250*noise( uv ); uv = m*uv;
            f += 0.0625*noise( uv ); uv = m*uv;
            f = 0.5 + 0.5*f;
            return f;
        }


        void main() {
            vec2 uv = vUv;
            vec2 q = uv;
            q.x *= 5.;
            q.y *= 2.;
            float strength = floor(q.x+1.);
            float T3 = max(3.,1.25*strength)*iTime*2.0;
            q.x = mod(q.x,1.)-0.5;
            q.y -= 0.25;
            float n = fbm(strength*q - vec2(0,T3));
            float c = 1. - 16. * pow( max( 0., length(q*vec2(1.8+q.y*1.5,.75) ) - n * max( 0., q.y+.25 ) ),1.2 );
        //  float c1 = n * c * (1.5-pow(1.25*uv.y,4.));
            float c1 = n * c * (1.5-pow(2.50*uv.y,4.));
            c1=clamp(c1,0.,1.);

            vec3 col = vec3(1.5*c1, 1.5*c1*c1*c1,c1*c1*c1*c1*c1*c1);
            
        #ifdef BLUE_FLAME
            col = col.zyx;
        #endif
        #ifdef GREEN_FLAME
            col = 0.85*col.yxz;
        #endif
            
            float a = c * (1.-pow(uv.y,3.));
            if(uv.x > 0.2 && uv.x < 0.4){  //0.2 0.4
              if(mix(vec3(0.0),col,a).y > 0.05){

                gl_FragColor = vec4( mix(vec3(0.0),col,a), a);
              }else{
                gl_FragColor = vec4( 0.0, 0.0, 0.0, 0.0);
              }
            }else{
                gl_FragColor = vec4( 0.0, 0.0, 0.0, 0.0);
            }
        }
        `,
          transparent: true,
          side: THREE.DoubleSide
        })


        realFire = new THREE.Mesh(new THREE.PlaneGeometry(2,1), realFireShader)
        let realFire2 = new THREE.Mesh(new THREE.PlaneGeometry(2,2), realFireShader)

        realFire.position.x = 0.2
        realFire.position.y = 0.8
        realFire.position.z = 0.28

        realFire.geometry.translate(0.4,0,0)

        //realFire.rotation.y = Math.PI / 4

        realFire2.position.x = 0.2
        realFire2.position.y = 1.3
        realFire2.position.z = -0.2

        realFire2.rotation.y = Math.PI / 2

        scene.add(realFire)
        //scene.add(realFire2)
        //backgrondPlane.position.z = -0.1

        backgrondPlane.receiveShadow = true;


        scene.add(backgrondPlane)


        // floor

        const floor = new THREE.Mesh(new THREE.BoxGeometry(10,1,10), new THREE.MeshBasicMaterial({color: 0x000000}))
        floor.position.y = -1.50
        scene.add(floor)




        const thirdFire = new THREE.Mesh(geometry, material.clone())
        const fourFire = new THREE.Mesh(geometry, material.clone())
        const fiveFire = new THREE.Mesh(geometry, material.clone())
        const sixFire = new THREE.Mesh(geometry, material.clone())
        const sevenFire = new THREE.Mesh(geometry, material.clone())


        // Light

        const light =  new THREE.DirectionalLight("#ffffff", 0.2);
        var cameraNear = 0.00001, cameraFar = 5000;
        light.castShadow = true;
        light.shadow.mapSize.width = 4024;
        light.shadow.mapSize.height = 4024;
        light.shadow.camera.near = cameraNear;
        light.shadow.camera.far = cameraFar;


        light.position.z = 400
        light.position.x = 200
        light.position.y = 100

        //light.intensity = 2
        scene.add( light )


        const light2 = new THREE.AmbientLight( 0xffffff );
        light2.intensity = 0.4
        scene.add( light2 );

        const pointLight = new THREE.PointLight("#FFAB0F", 10)
        pointLight.distance = 1

        scene.add(pointLight)

        

         const loader2 = new GLTFLoader();
            loader2.load( 'zuko5.gltf', function ( gltf ) { // zuko3.gltf
              const g = gltf.scene
              g.castShadow = true;
              g.receiveShadow = true;

              g.traverse(_ => _.frustumCulled = false)
              //g.scale.set(0.8, 0.8, 0.8)

              g.traverse(node => {
                if(node.isMesh) node.castShadow = true
              })

              //g.rotation.y = Math.PI / 4
              //g.position.x = -2
              //g.position.z = -5

              scene.add( g )
              // scene.children[2].position.z = 0.5
              // scene.children[2].position.y = -1

              var pivot = new THREE.Group();
              scene.add( pivot );
              pivot.name = "pivot"

              pivot.add( g );
              pivot.add(realFire)
              //pivot.add(realFire2)
              pivot.position.x = -1.85
              pivot.position.z = 0.5
              //pivot.position.z = -0.1

              //g.position.set( 4, - 3, - 5 )
              g.position.set( -1.0, -0.95, -0.05)

              const cube = new THREE.Mesh(new THREE.BoxGeometry(0.05, 0.05, 0.05), new THREE.MeshBasicMaterial({color: 0xFF0000}))
              scene.add(cube)
              cube.position.copy(g.position)

              const cube1 = new THREE.Mesh(new THREE.BoxGeometry(0.01, 5, 0.01), new THREE.MeshBasicMaterial({color: 0x00ff00}))
              scene.add(cube1)
              cube1.position.copy(pivot.position)

              

              

            
              mixer = new AnimationMixer(gltf.scene)

              animationAction = mixer.clipAction(gltf.animations[0])
              animationAction.setLoop(THREE.LoopOnce);
              animationAction.clampWhenFinished = true;
              animationAction.enable = true;

              ///  WTF

              const geometry2 = new THREE.TorusGeometry(0.3, 0.1, 8, 16, Math.PI)
              //const material2 = new THREE.MeshBasicMaterial({color: 0xffff00 })

              const material2 = new THREE.ShaderMaterial({
                side:THREE.DoubleSide,
                  uniforms: {
                      uTime: { type: "f", value: 0 },
                      uTimeForStartTorusFire: { type: "f", value: timeForStartTorusFire },
                      uSpendedTimeBeforeGoStart: { type: "f", value: spendedTimeBeforeGoStart },
                      
                  },
                  transparent: true,
                  vertexShader: `
                  uniform float uTime;
                  varying vec2 vUv;
                  varying vec3 vPosition;
                  varying float vNoise;

                  float pseudoRandom(float seed) {
                    return fract(sin(seed) * 43758.5453);
                  }

                  float noise(vec3 point) {
                    float dt = dot(point, vec3(12.9898, 78.233, 123.45));
                    float sn = (sin(dt) * 43758.5453123);
                    return fract(sn);
                  }

                  void main() {
                    vUv = uv;
                    vPosition = position;

                    float noiseFactor = noise(position + uTime);
                    vNoise = noiseFactor * 1.5;

                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                  }

                  `,
                  fragmentShader: `
                  uniform float uTime; 
                  uniform float uTimeForStartTorusFire;
                  uniform float uSpendedTimeBeforeGoStart;
                  varying vec2 vUv;
                  varying vec3 vPosition;
                  varying float vNoise;

                  float random (vec2 st) {
                    return fract(sin(dot(st.xy,vec2(12.9898,78.233)))*43758.5453123 * abs(sin(uTime)));
                  }

                  void main() {

                    float rnd = random( vUv );

                    // Высота относительно центра огня
                    float heightFactor = smoothstep(0.0, 30.0, vPosition.y);

                    // Определяем цвета для эффекта пламени
                    vec3 colorBottom = vec3(1.0, 1.0, 0.0); // Желтый
                    vec3 colorMiddle = vec3(1.0, 0.5, 0.0); // Оранжевый
                    vec3 colorTop = vec3(1.0, 0.0, 0.0); // Красный

                    // Смешиваем цвета, используя шум и высоту для создания эффекта пламени
                    vec3 color = mix(colorBottom, colorMiddle, clamp(vNoise + 0.2, 0.0, 1.0));
                    color = mix(color, colorTop, heightFactor);

                    // Плавные переходы между цветами с точечным эффектом
                    color *= (1.0 - heightFactor) + vNoise * heightFactor;

                    float alpha = 0.0;
                    if(vUv.x < (uTime - uSpendedTimeBeforeGoStart - uTimeForStartTorusFire) * 10.0){
                      alpha = 1.0;
                    }

                    gl_FragColor = vec4(color, alpha);
                    
                  }`
              })



              torus = new THREE.Mesh(geometry2, material2)

              scene.add(torus)



              torus.rotation.z = -Math.PI / 2
              torus.rotation.x = Math.PI + Math.PI / 2 + Math.PI  / 6
              torus.rotation.y = -Math.PI / 8

              torus.position.x = -0.5


              /// THIRD
              thirdFire.rotation.z = -Math.PI / 4
              thirdFire.position.x = 1.4
              thirdFire.position.y = 0.9
              scene.add(thirdFire)

              //FOUR

              fourFire.position.x = 1.7
              fourFire.position.y = 0.35
              fourFire.rotation.z = -Math.PI / 2
              scene.add(fourFire)

              // FIVE

              fiveFire.position.x = 1.7
              fiveFire.position.y = 0.2
              fiveFire.rotation.z = -Math.PI / 2
              scene.add(fiveFire)

              // SIX

              sixFire.position.x = -1.7
              sixFire.position.y = 0.2
              sixFire.rotation.z = -Math.PI / 2
              scene.add(sixFire)

              // SEVEN

              sevenFire.position.x = -2.2
              sevenFire.position.y = 0.8
              sevenFire.rotation.z = Math.PI / 4
              scene.add(sevenFire)


              

              render()
          })





        renderer = new THREE.WebGLRenderer()
        renderer.shadowMap.enabled = true
        renderer.shadowMap.type = THREE.BasicShadowMap
        renderer.setPixelRatio( window.devicePixelRatio )
        renderer.setSize( window.innerWidth, window.innerHeight )
        // renderer.toneMapping = THREE.ACESFilmicToneMapping;
        // renderer.toneMappingExposure = 1;
        // renderer.outputEncoding = THREE.sRGBEncoding;
        container.appendChild( renderer.domElement );

        const tween = new TWEEN.Tween(camera.position, false) // Create a new tween that modifies 'coords'.
            .to({x: -0.8, y: 0, z: 7},2000) // Move to (300, 200) in 1 second.
            .easing(TWEEN.Easing.Cubic.InOut) // Use an easing function to make the animation smooth.
            // .yoyo(false)
            // .repeat(1)
            .onUpdate(coords => {
              // Called after tween.js updates 'coords'.
              // Move 'box' to the position described by 'coords' with a CSS translation
              //console.log("update", coords)
                            camera.position.set(coords.x, coords.y, coords.z)
            })
            //.start() // Start the tween immediately.
        //tween.repeat(1)


        const gui = new GUI()

        const gg = {"controls": false, "visible": true}

        const controls = new OrbitControls( camera, renderer.domElement );
        controls.minDistance = 2;
        controls.maxDistance = 40;
        controls.target.set( 0, 0, - 0.2 );
        controls.enableRotate = false;
        controls.update();

        gui.add(gg, "controls").onChange(e => {
          if(e){
            controls.enableRotate = true;
          }else{
            // to disable rotation
            controls.enableRotate = false;
          }
        })

        gui.add(gg, "visible").onChange(bool => {
          scene.children.find(child => child.name == "pivot").traverse(_ => _.visible = bool)
        })

        let Configuracion=function(){
          this.color = new THREE.Color(0.3333333432674408, 0.12452887743711472, 0.10101473331451416).getHexString()
        }
        let conf = new Configuracion()
        let controlador = gui.addColor( conf, 'color').onChange( colorValue => {
          const pivot = scene.children.find(child => child.name == "pivot")
          pivot.traverse(child => {
            if(child.material) child.material.color = new THREE.Color(colorValue)
          })
        })

        const f1 = gui.addFolder("PointLight")
        f1.add(pointLight, "distance").min(0).max(10).step(0.1)
        f1.add(pointLight, "intensity").min(0).max(10).step(0.1)
        f1.add(pointLight.position, "z").min(0).max(10).step(0.1)

        const f2 = gui.addFolder("AmbientLight")
        f2.add(light2, "intensity").min(0).max(10).step(0.1)

        const f3 = gui.addFolder("DirectionalLight")
        f3.add(light, "intensity").min(0).max(10).step(0.1)
        f3.add(light.position, "x").min(0).max(400)
        f3.add(light.position, "y").min(0).max(400)
        f3.add(light.position, "z").min(0).max(400)

        window.addEventListener( 'resize', onWindowResize )

      function resizeRendererToDisplaySize(renderer) {
        const canvas = renderer.domElement
        const width = canvas.clientWidth
        const height = canvas.clientHeight
        const needResize = canvas.width !== width || canvas.height !== height
        if (needResize) {
          renderer.setSize(width, height, false)
        }
        return needResize
      }

      function updateUniforms() {
        scene.traverse((child) => {
          if (child instanceof THREE.Mesh && child.material.type === 'ShaderMaterial' && child.material.uniforms.uTime) {
            child.material.uniforms.uTime.value = TIME
            resizeRendererToDisplaySize(renderer)
 
            const canvas = renderer.domElement
            const plane = scene.children.find(child => child.name == "plane")
            child.material.needsUpdate = true;
          }
        })       
      }

      function onWindowResize() {

        camera.aspect = window.innerWidth / window.innerHeight
        camera.updateProjectionMatrix()

        renderer.setSize( window.innerWidth, window.innerHeight )

        render()

      }

      const clock = new THREE.Clock()
      sphere.frustumCulled = false;

      let once = false

      function render() {
        //camera.lookAt(0, -0.2, 0)

        TIME += 0.005;
        realFire.material.uniforms.iTime.value = TIME
        camera.lookAt(new THREE.Vector3(-0.8, 0, 0))

        // if(TIME > 1.2){
        //   isStartAnimation = true
        // }

        //console.log(clock)
        if(animationAction && isStartAnimation){
          mixer.update(clock.getDelta()) // THIS IS ANIMATION

          animationAction.play()
        }

        //console.log(mixer.time)

        if(!isStartAnimation){
          spendedTimeBeforeGoStart = TIME
          torus.material.uniforms.uSpendedTimeBeforeGoStart.value = TIME
        }

        requestAnimationFrame(render)
        updateUniforms()

        if(mixer.time > 0.4){
          sphere.position.x += 0.4
          pointLight.distance = 6
          pointLight.position.y = 2
          pointLight.position.x = sphere.position.x
          //pointLight.position.copy(sphere.position)
          if(material.uniforms.uScaleY.value < 1.4){
            material.uniforms.uScaleY.value = material.uniforms.uScaleY.value + 0.4
          }
        }

        if(mixer.time > 0.6){
          acseleration += 0.002

          torus.position.x += 0.07 + acseleration
          torus.position.y += 0.035 + acseleration

          pointLight.position.x = torus.position.x
          pointLight.position.y = torus.position.y
          //pointLight.position.copy(torus.position)

          if(torus.scale.x < 5){
            torus.scale.x += 0.125
            torus.scale.y += 0.125
            torus.scale.z += 0.05
          }
        }

        if(mixer.time > 1.7){ //TIME > timeForStartThirdFire + spendedTimeBeforeGoStart
          thirdFire.scale.set(1,1,1)
          thirdFire.position.x += 0.4
          thirdFire.position.y += 0.4

          pointLight.position.x = thirdFire.position.x
          pointLight.position.y = thirdFire.position.y
          //pointLight.position.copy(thirdFire.position)

          if(thirdFire.material.uniforms.uScaleY.value < 1.4){
            thirdFire.material.uniforms.uScaleY.value = thirdFire.material.uniforms.uScaleY.value + 0.4
          }
        }

        if(mixer.time > 2){ //TIME > timeForStartFourFire + spendedTimeBeforeGoStart
          fourFire.scale.set(1,1,1)
          fourFire.position.x += 0.4

          pointLight.position.x = fourFire.position.x
          pointLight.position.y = fourFire.position.y
          //pointLight.position.copy(fourFire.position)
          if(fourFire.material.uniforms.uScaleY.value < 1.4){
            fourFire.material.uniforms.uScaleY.value = fourFire.material.uniforms.uScaleY.value + 0.4
          }
        }

        if(mixer.time > 2.4){ // TIME > timeForStartFiveFire + spendedTimeBeforeGoStart
          fiveFire.scale.set(1,1,1)
          fiveFire.position.x += 0.4

          pointLight.position.x = fiveFire.position.x
          pointLight.position.y = fiveFire.position.y
          //pointLight.position.copy(fiveFire.position)
          if(fiveFire.material.uniforms.uScaleY.value < 1.4){
            fiveFire.material.uniforms.uScaleY.value = fiveFire.material.uniforms.uScaleY.value + 0.4
          }
        }
        if(mixer.time > 3.2){ // TIME > timeForStartFiveFire + spendedTimeBeforeGoStart
          sixFire.scale.set(1,1,1)
          sixFire.position.x -= 0.4

          pointLight.position.x = sixFire.position.x
          pointLight.position.y = sixFire.position.y
          //pointLight.position.copy(sixFire.position)

          if(sixFire.material.uniforms.uScaleY.value < 1.4){
            sixFire.material.uniforms.uScaleY.value = sixFire.material.uniforms.uScaleY.value + 0.4
          }
        }
        if(mixer.time > 4){
          sevenFire.scale.set(1,1,1)
          //pointLight.position.copy(sevenFire.position)
          sevenFire.position.x -= 0.4
          sevenFire.position.y += 0.4

          pointLight.position.x = sevenFire.position.x
          pointLight.position.y = sevenFire.position.y

          if(sevenFire.material.uniforms.uScaleY.value < 1.4){
            sevenFire.material.uniforms.uScaleY.value = sevenFire.material.uniforms.uScaleY.value + 0.4
          }
        }

        if(mixer.time > 5){
          isAnimationEnd = true

          if(!isPlayIn){
            isPlayIn = true
            tween.start()
            
          }
          tween.update()
        }



        if(TIME > 0.01 && TIME < timeForStartFirstFire){
          //sphere.visible = false
          sphere.scale.set(0,0,0)
          torus.scale.set(0,0,0)
          thirdFire.scale.set(0,0,0)
          fourFire.scale.set(0,0,0)
          fiveFire.scale.set(0,0,0)
          sixFire.scale.set(0,0,0)
          sevenFire.scale.set(0,0,0)
        }

        // scaling sphere
        if(TIME > spendedTimeBeforeGoStart + timeForStartFirstFire  && isStartAnimation){
          const h = 0.3 + (TIME - timeForStartFirstFire) *6
          //sphere.scale.set(h,h,h)
          sphere.scale.set(1,1,1)
        }


        


        renderer.render( scene, camera )
      }

      render()

      }

      



    </script>

  </body>
</html>