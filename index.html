<!DOCTYPE html>
<html lang="en">
  <head>
    <title>Blender-to-Three.js App Template</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <style>
      body {
        margin: 0px;
      }
    </style>
  </head>

  <body>
    <script type="module">


      import * as THREE from './three.module.js';

      import { OrbitControls } from './OrbitControls.js';
      import { GLTFLoader } from './GLTFLoader.js';
      import { RGBELoader } from './RGBELoader.js';

      let camera, scene, renderer;
      let TIME = 0

      init();
      render();



      function init() {

        const container = document.createElement( 'div' );
        document.body.appendChild( container );

        camera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 0.25, 20 );
        camera.position.set( - 1.8, 0.6, 2.7 );

        scene = new THREE.Scene();

        const cube = new THREE.BoxGeometry(0.5,0.5,0.5)
        const material = new THREE.ShaderMaterial({
            uniforms: {
                diffuse: { value: new THREE.Color(0xffffff) },
                u_time: { type: "f", value: 0 },
                iResolution:  { value: new THREE.Vector3() },
            },
            vertexShader: `
                uniform float u_time;

                varying vec2 vUv;

                void main() {
                    // vUv = uv;

                    // vec3 delta = normal * sin(position.x * position.y * u_time / 10.0);
                    // vec3 newPosition = position + delta;

                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                }`,
            fragmentShader: `
                uniform vec3 diffuse;
                uniform float u_time;
                uniform vec3 iResolution;
                varying vec2 vUv;

                vec2 hash( vec2 p )
                {
                  p = vec2( dot(p,vec2(127.1,311.7)),
                       dot(p,vec2(269.5,183.3)) );
                  return -1.0 + 2.0*fract(sin(p)*43758.5453123);
                }

                float noise( in vec2 p )
                {
                  const float K1 = 0.366025404; // (sqrt(3)-1)/2;
                  const float K2 = 0.211324865; // (3-sqrt(3))/6;
                  
                  vec2 i = floor( p + (p.x+p.y)*K1 );
                  
                  vec2 a = p - i + (i.x+i.y)*K2;
                  vec2 o = (a.x>a.y) ? vec2(1.0,0.0) : vec2(0.0,1.0);
                  vec2 b = a - o + K2;
                  vec2 c = a - 1.0 + 2.0*K2;
                  
                  vec3 h = max( 0.5-vec3(dot(a,a), dot(b,b), dot(c,c) ), 0.0 );
                  
                  vec3 n = h*h*h*h*vec3( dot(a,hash(i+0.0)), dot(b,hash(i+o)), dot(c,hash(i+1.0)));
                  
                  return dot( n, vec3(70.0) );
                }

                float fbm(vec2 uv)
                {
                  float f;
                  mat2 m = mat2( 1.6,  1.2, -1.2,  1.6 );
                  f  = 0.5000*noise( uv ); uv = m*uv;
                  f += 0.2500*noise( uv ); uv = m*uv;
                  f += 0.1250*noise( uv ); uv = m*uv;
                  f += 0.0625*noise( uv ); uv = m*uv;
                  f = 0.5 + 0.5*f;
                  return f;
                }


                void mainImage( out vec4 fragColor, in vec2 fragCoord )
                {
                    // Normalized pixel coordinates (from 0 to 1)
                    vec2 uv = fragCoord/iResolution.xy;
                 
                    vec2 q = uv;
                    q.x *= 5.;
                    q.y *= 2.;
                    float strength = floor(q.x+1.);
                    float T3 = max(3.,1.25*strength)*u_time;
                    q.x = mod(q.x,1.)-0.5;
                    q.y -= 0.25;
                    float n = fbm(strength*q - vec2(0,T3));
                    float c = 1. - 16. * pow( max( 0., length(q*vec2(1.8+q.y*1.5,.75) ) - n * max( 0., q.y+.25 ) ),1.2 );
                  //  float c1 = n * c * (1.5-pow(1.25*uv.y,4.));
                    float c1 = n * c * (1.5-pow(2.50*uv.y,4.));
                    c1=clamp(c1,0.,1.);

                    vec3 col = vec3(1.5*c1, 1.5*c1*c1*c1, c1*c1*c1*c1*c1*c1);
                    
                  #ifdef BLUE_FLAME
                    col = col.zyx;
                  #endif
                  #ifdef GREEN_FLAME
                    col = 0.85*col.yxz;
                  #endif
                    
                    float a = c * (1.-pow(uv.y,3.));
                    fragColor = vec4( mix(vec3(0.),col,a), 1.0);
                }
                 
                void main() {
                  mainImage(gl_FragColor, gl_FragCoord.xy);
                }
                `
        });
        material.uniforms.diffuse.value = new THREE.Color(0,1,1);
        material.uniforms.u_time.value = TIME
        
        const mesh = new THREE.Mesh(cube, material)
        //scene.add(mesh)

        const plane = new THREE.PlaneGeometry(3,3,3)
        scene.add(new THREE.Mesh(plane, material))

        new RGBELoader()
          .load( 'environment.hdr', function ( texture ) {

            texture.mapping = THREE.EquirectangularReflectionMapping;

            scene.background = texture;
            scene.environment = texture;

            render();

            // model

            // const loader = new GLTFLoader();
            // loader.load( 'suzanne.gltf', function ( gltf ) {

            //   scene.add( gltf.scene );

            //   render();

            // } );

          } );


        

        renderer = new THREE.WebGLRenderer( { antialias: true } );
        renderer.setPixelRatio( window.devicePixelRatio );
        renderer.setSize( window.innerWidth, window.innerHeight );
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        renderer.toneMappingExposure = 1;
        renderer.outputEncoding = THREE.sRGBEncoding;
        container.appendChild( renderer.domElement );

        const controls = new OrbitControls( camera, renderer.domElement );
        controls.addEventListener( 'change', render ); // use if there is no animation loop
        controls.minDistance = 2;
        controls.maxDistance = 10;
        controls.target.set( 0, 0, - 0.2 );
        controls.update();

        window.addEventListener( 'resize', onWindowResize );

      }

      function resizeRendererToDisplaySize(renderer) {
        const canvas = renderer.domElement;
        const width = canvas.clientWidth;
        const height = canvas.clientHeight;
        const needResize = canvas.width !== width || canvas.height !== height;
        if (needResize) {
          renderer.setSize(width, height, false);
        }
        return needResize;
      }

      function updateUniforms() {
          scene.traverse((child) => {
              if (child instanceof THREE.Mesh
                  && child.material.type === 'ShaderMaterial') {
                  //console.log({TIME, time: child.material.uniforms})
                  child.material.uniforms.u_time.value = TIME;
                  resizeRendererToDisplaySize(renderer);
 
                  const canvas = renderer.domElement;
                  child.material.uniforms.iResolution.value.set(canvas.width, canvas.height, 1);
                  child.material.needsUpdate = true;
              }
          });
          
        }

      function onWindowResize() {

        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();

        renderer.setSize( window.innerWidth, window.innerHeight );

        render();

      }

      //


      function render() {


        

        requestAnimationFrame(render)
        TIME += 0.005;
        updateUniforms();
        renderer.render( scene, camera );
        

      }

    </script>

  </body>
</html>
